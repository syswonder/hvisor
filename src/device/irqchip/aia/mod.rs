// Copyright (c) 2025 Syswonder
// hvisor is licensed under Mulan PSL v2.
// You can use this software according to the terms and conditions of the Mulan PSL v2.
// You may obtain a copy of Mulan PSL v2 at:
//     http://license.coscl.org.cn/MulanPSL2
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
// FIT FOR A PARTICULAR PURPOSE.
// See the Mulan PSL v2 for more details.
//
// Syswonder Website:
//      https://www.syswonder.org
//
// Authors:
//

// Note: hvisor's AIA supports MSI-mode, doesn't support Direct-mode.

pub mod aplic;
pub mod imsic;
pub mod vaplic;
pub mod vimsic;
use crate::arch::cpu::this_cpu_id;
use crate::arch::zone::HvArchZoneConfig;
use crate::config::HvZoneConfig;
use crate::consts::{MAX_CPU_NUM, MAX_ZONE_NUM};
use crate::error::HvResult;
use crate::memory::GuestPhysAddr;
use crate::memory::HostPhysAddr;
use crate::memory::MMIOAccess;
use crate::memory::MemFlags;
use crate::memory::MemoryRegion;
use crate::percpu::this_cpu_data;
use crate::platform::HW_IRQS;
use crate::platform::{
    BOARD_APLIC_INTERRUPTS_NUM, IMSIC_GUEST_INDEX, IMSIC_GUEST_NUM, IMSIC_S_BASE,
};
use crate::root_zone_config;
use crate::zone::Zone;
pub use aplic::*;
use heapless::FnvIndexMap;
pub use imsic::*;
use spin::Once;
pub use vaplic::*;
pub use vimsic::*;

// Physical APLIC
pub static APLIC: Once<Aplic> = Once::new();
// The MAX_ZONE_NUM should be the power of 2.
static mut VAPLIC_MAP: Option<FnvIndexMap<usize, VirtualAPLIC, MAX_ZONE_NUM>> = None;

pub fn init_aplic(aplic_base: usize) {
    APLIC.call_once(|| Aplic::new(aplic_base));
}

pub fn host_aplic<'a>() -> &'a Aplic {
    APLIC.get().expect("Uninitialized hypervisor aplic!")
}

pub fn primary_init_early() {
    // Init the physical APLIC global part
    let root_config = root_zone_config();
    init_aplic(root_config.arch_config.aplic_base as usize);
    host_aplic().init_global(this_cpu_id(), BOARD_APLIC_INTERRUPTS_NUM);

    unsafe {
        VAPLIC_MAP = Some(FnvIndexMap::new());
    }
}

pub fn primary_init_late() {
    info!("APLIC do nothing in primary_init_late");
}

pub fn percpu_init() {
    // Each hart init its own imisc.
    imsic_init();
}

/// handle Zone's aplic mmio access.
pub fn vaplic_handler(mmio: &mut MMIOAccess, _arg: usize) -> HvResult {
    let value = this_cpu_data()
        .zone
        .as_ref()
        .unwrap()
        .read()
        .get_vaplic()
        .vaplic_emul_access(mmio.address, mmio.size, mmio.value, mmio.is_write);
    if !mmio.is_write {
        // read from vplic
        mmio.value = value as usize;
    }
    Ok(())
}

pub fn inject_irq(irq: usize, is_hardware: bool) {
    // Due to hvisor doesn't handle external interrupt, inject_irq related interrupt is generated by software.
    if is_hardware {
        error!("For hvisor's riscv-aia, hardware interrupt should be transferred to IMSIC's interrupt file.");
        return;
    }
    // For hvisor on qemu-aia, only software interrupt will be injected.
    // Hardware interrupt will be transferred to IMSIC's interrupt file directly.
    let target = this_cpu_data()
        .zone
        .as_ref()
        .unwrap()
        .read()
        .get_vaplic()
        .vaplic_get_target(irq);
    let mut hart = (target >> 18) & 0x3FFF;
    // let guest = (target >> 12) & 0x3F;
    let eiid = target & 0x3FF;
    // Transfer vhart_id to phart_id.
    hart = hart
        + this_cpu_data()
            .zone
            .as_ref()
            .unwrap()
            .read()
            .cpu_set
            .first_cpu()
            .unwrap() as u32;
    imsic_trigger(hart, IMSIC_GUEST_INDEX as u32, eiid);
}

/// Print all keys in the VAPLIC_MAP for debugging purposes.
fn print_keys() {
    info!("VAPLIC_MAP keys:");
    unsafe {
        if let Some(map) = &VAPLIC_MAP {
            for (&key, _) in map.iter() {
                info!("\tZone {}'s vaplic in VAPLIC_MAP", key);
            }
        }
    }
}

impl Zone {
    /// Initial the virtual APLIC related to thiz Zone.
    pub fn vaplic_init(&mut self, config: &HvZoneConfig) {
        // Create a new VirtualAPLIC for this Zone.
        unsafe {
            if let Some(map) = &mut VAPLIC_MAP {
                if map.contains_key(&self.id) {
                    panic!("VirtualAPLIC for Zone {} already exists!", self.id);
                }
                let vaplic = vaplic::VirtualAPLIC::new(
                    config.arch_config.aplic_base,
                    BOARD_APLIC_INTERRUPTS_NUM,
                );
                // Insert into Map <zone_id, vplic>
                let _ = map.insert(self.id, vaplic);
            } else {
                panic!("VAPLIC_MAP is not initialized!");
            }
        }
        info!("VirtualAPLIC for Zone {} initialized successfully", self.id);
        print_keys();
    }

    /// Initial the virtual IMSIC related to thiz Zone.
    pub fn vimsic_init(&mut self, config: &HvZoneConfig) {
        info!("Zone {} vIMSIC init", self.id);
        vimsic::vimsic_init(self, IMSIC_S_BASE, IMSIC_GUEST_NUM);
    }

    pub fn get_vaplic(&self) -> &VirtualAPLIC {
        unsafe {
            VAPLIC_MAP
                .as_ref()
                .expect("VAPLIC_MAP is not initialized!")
                .get(&self.id)
                .expect("VirtualAPLIC for this Zone does not exist!")
        }
    }

    pub fn arch_irqchip_reset(&self) {
        // We should make sure only one cpu to do this.
        // This func will only be called by one root zone's cpu.
        let host_aplic = host_aplic();
        let vaplic = self.get_vaplic();
        for (index, &word) in self.irq_bitmap.iter().enumerate() {
            for bit_position in 0..32 {
                if word & (1 << bit_position) != 0 {
                    let irq_id = index * 32 + bit_position;
                    // Skip the irq_id which is not in HW_IRQS
                    if !HW_IRQS.iter().any(|&x| x == irq_id as _) {
                        continue;
                    }
                    info!("Reset irq_id {} in VirtualAPLIC", irq_id);
                    host_aplic.set_clrienum(irq_id as u32);
                    host_aplic.set_sourcecfg(irq_id as u32, SourceMode::Inactive);
                    host_aplic.set_clripnum(irq_id as u32);
                }
            }
        }

        self.cpu_set.iter().for_each(|cpuid| {
            // Clear the events related to this cpu.
            info!("Clear events related to cpu {}", cpuid);
            crate::event::clear_events(cpuid);
        });

        unsafe {
            if let Some(map) = &mut VAPLIC_MAP {
                map.remove(&self.id);
            } else {
                panic!("VAPLIC_MAP is not initialized!");
            }
        }
        print_keys();
    }

    fn insert_irq_to_bitmap(&mut self, irq: u32) {
        let irq_index = irq / 32;
        let irq_bit = irq % 32;
        self.irq_bitmap[irq_index as usize] |= 1 << irq_bit;
    }

    /// irq_bitmap_init, and set these irqs' hw bit in vplic to true.
    pub fn irq_bitmap_init(&mut self, irqs: &[u32]) {
        // insert to zone.irq_bitmap
        for irq in irqs {
            let irq_id = *irq;
            // They are hardware interrupts.
            if HW_IRQS.iter().any(|&x| x == irq_id) {
                self.get_vaplic().vaplic_set_hw(irq_id as usize, true);
                info!("Set irq {} to hardware interrupt", irq_id);
            }
            self.insert_irq_to_bitmap(irq_id);
        }
        // print irq_bitmap
        for (index, &word) in self.irq_bitmap.iter().enumerate() {
            for bit_position in 0..32 {
                if word & (1 << bit_position) != 0 {
                    let interrupt_number = index * 32 + bit_position;
                    info!(
                        "Found interrupt in Zone {} irq_bitmap: {}",
                        self.id, interrupt_number
                    );
                }
            }
        }
    }

    pub fn vaplic_mmio_init(&mut self, arch: &HvArchZoneConfig) {
        if arch.aplic_base == 0 {
            panic!("vplic_mmio_init: plic_base is null");
        }
        self.mmio_region_register(arch.aplic_base, arch.aplic_size, vaplic_handler, 0);
    }
}
