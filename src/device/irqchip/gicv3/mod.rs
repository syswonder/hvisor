// SPDX-License-Identifier: MIT OR Apache-2.0
//
// Copyright (c) 2020-2022 Andre Richter <andre.o.richter@gmail.com>

//! GICv2 Driver - ARM Generic Interrupt Controller v2.
//!
//! The following is a collection of excerpts with useful information from
//!   - `Programmer's Guide for ARMv8-A`
//!   - `ARM Generic Interrupt Controller Architecture Specification`
//!
//! # Programmer's Guide - 10.6.1 Configuration
//!
//! The GIC is accessed as a memory-mapped peripheral.
//!
//! All cores can access the common Distributor, but the CPU interface is banked, that is, each core
//! uses the same address to access its own private CPU interface.
//!
//! It is not possible for a core to access the CPU interface of another core.
//!
//! # Architecture Specification - 10.6.2 Initialization
//!
//! Both the Distributor and the CPU interfaces are disabled at reset. The GIC must be initialized
//! after reset before it can deliver interrupts to the core.
//!
//! In the Distributor, software must configure the priority, target, security and enable individual
//! interrupts. The Distributor must subsequently be enabled through its control register
//! (GICD_CTLR). For each CPU interface, software must program the priority mask and preemption
//! settings.
//!
//! Each CPU interface block itself must be enabled through its control register (GICD_CTLR). This
//! prepares the GIC to deliver interrupts to the core.
//!
//! Before interrupts are expected in the core, software prepares the core to take interrupts by
//! setting a valid interrupt vector in the vector table, and clearing interrupt mask bits in
//! PSTATE, and setting the routing controls.
//!
//! The entire interrupt mechanism in the system can be disabled by disabling the Distributor.
//! Interrupt delivery to an individual core can be disabled by disabling its CPU interface.
//! Individual interrupts can also be disabled (or enabled) in the distributor.
//!
//! For an interrupt to reach the core, the individual interrupt, Distributor and CPU interface must
//! all be enabled. The interrupt also needs to be of sufficient priority, that is, higher than the
//! core's priority mask.
//!
//! # Architecture Specification - 1.4.2 Interrupt types
//!
//! - Peripheral interrupt
//!     - Private Peripheral Interrupt (PPI)
//!         - This is a peripheral interrupt that is specific to a single processor.
//!     - Shared Peripheral Interrupt (SPI)
//!         - This is a peripheral interrupt that the Distributor can route to any of a specified
//!           combination of processors.
//!
//! - Software-generated interrupt (SGI)
//!     - This is an interrupt generated by software writing to a GICD_SGIR register in the GIC. The
//!       system uses SGIs for interprocessor communication.
//!     - An SGI has edge-triggered properties. The software triggering of the interrupt is
//!       equivalent to the edge transition of the interrupt request signal.
//!     - When an SGI occurs in a multiprocessor implementation, the CPUID field in the Interrupt
//!       Acknowledge Register, GICC_IAR, or the Aliased Interrupt Acknowledge Register, GICC_AIAR,
//!       identifies the processor that requested the interrupt.
//!
//! # Architecture Specification - 2.2.1 Interrupt IDs
//!
//! Interrupts from sources are identified using ID numbers. Each CPU interface can see up to 1020
//! interrupts. The banking of SPIs and PPIs increases the total number of interrupts supported by
//! the Distributor.
//!
//! The GIC assigns interrupt ID numbers ID0-ID1019 as follows:
//!   - Interrupt numbers 32..1019 are used for SPIs.
//!   - Interrupt numbers 0..31 are used for interrupts that are private to a CPU interface. These
//!     interrupts are banked in the Distributor.
//!       - A banked interrupt is one where the Distributor can have multiple interrupts with the
//!         same ID. A banked interrupt is identified uniquely by its ID number and its associated
//!         CPU interface number. Of the banked interrupt IDs:
//!           - 00..15 SGIs
//!           - 16..31 PPIs
#![allow(dead_code)]
pub mod gicd;
pub mod gicr;
pub mod vgic;

use core::arch::asm;
use core::ptr::write_volatile;

use fdt::Fdt;
use spin::Once;

use self::gicd::{enable_gic_are_ns, GICD_ICACTIVER, GICD_ICENABLER};
use self::gicr::enable_ipi;
use crate::arch::aarch64::sysreg::{read_sysreg, smc_arg1, write_sysreg};
use crate::consts::MAX_CPU_NUM;

use crate::event::check_events;
use crate::hypercall::SGI_IPI_ID;
use crate::zone::Zone;

//TODO: add Distributor init
pub fn gicc_init() {
    //TODO: add Redistributor init
    let sdei_ver = unsafe { smc_arg1!(0xc4000020) }; //sdei_check();
    info!("gicv3 init: sdei version: {}", sdei_ver);

    // Make ICC_EOIR1_EL1 provide priority drop functionality only. ICC_DIR_EL1 provides interrupt deactivation functionality.
    let _ctlr = read_sysreg!(icc_ctlr_el1);
    write_sysreg!(icc_ctlr_el1, 0x2);
    // Set Interrupt Controller Interrupt Priority Mask Register
    let pmr = read_sysreg!(icc_pmr_el1);
    write_sysreg!(icc_pmr_el1, 0xf0);
    // Enable group 1 irq
    let _igrpen = read_sysreg!(icc_igrpen1_el1);
    write_sysreg!(icc_igrpen1_el1, 0x1);

    gicv3_clear_pending_irqs();
    let _vtr = read_sysreg!(ich_vtr_el2);
    let vmcr = ((pmr & 0xff) << 24) | (1 << 1) | (1 << 9); //VPMR|VENG1|VEOIM
    write_sysreg!(ich_vmcr_el2, vmcr);
    write_sysreg!(ich_hcr_el2, 0x1); //enable virt cpu interface
}

fn gicv3_clear_pending_irqs() {
    let vtr = read_sysreg!(ich_vtr_el2) as usize;
    let lr_num: usize = (vtr & 0xf) + 1;
    for i in 0..lr_num {
        write_lr(i, 0) //clear lr
    }
    let num_priority_bits = (vtr >> 29) + 1;
    /* Clear active priority bits */
    if num_priority_bits >= 5 {
        write_sysreg!(ICH_AP1R0_EL2, 0); //Interrupt Controller Hyp Active Priorities Group 1 Register 0 No interrupt active
    }
    if num_priority_bits >= 6 {
        write_sysreg!(ICH_AP1R1_EL2, 0);
    }
    if num_priority_bits > 6 {
        write_sysreg!(ICH_AP1R2_EL2, 0);
        write_sysreg!(ICH_AP1R3_EL2, 0);
    }
}

pub fn gicv3_handle_irq_el1() {
    if let Some(irq_id) = pending_irq() {
        // enum ipi_msg_type {
        //     IPI_WAKEUP,
        //     IPI_TIMER,
        //     IPI_RESCHEDULE,
        //     IPI_CALL_FUNC,
        //     IPI_CPU_STOP,
        //     IPI_IRQ_WORK,
        //     IPI_COMPLETION,
        //     /*
        //      * CPU_BACKTRACE is special and not included in NR_IPI
        //      * or tracable with trace_ipi_*
        //      */
        //     IPI_CPU_BACKTRACE,
        //     /*
        //      * SGI8-15 can be reserved by secure firmware, and thus may
        //      * not be usable by the kernel. Please keep the above limited
        //      * to at most 8 entries.
        //      */
        // };
        //SGI
        if irq_id < 8 {
            deactivate_irq(irq_id);
            let mut ipi_handled = false;
            if irq_id == SGI_IPI_ID as _ {
                info!("SGI_IPI_ID");
                ipi_handled = check_events();
            }
            if !ipi_handled {
                trace!("sgi get {}, inject", irq_id);
                inject_irq(irq_id, false);
            }
        } else if irq_id < 16 {
            warn!("skip sgi {}", irq_id);
            deactivate_irq(irq_id);
        } else {
            trace!("spi/ppi get {}", irq_id);
            //inject phy irq
            if irq_id > 31 {
                trace!("*** get spi_irq id = {}", irq_id);
            }
            deactivate_irq(irq_id);
            inject_irq(irq_id, true);
        }
    }
    trace!("handle done")
}

fn pending_irq() -> Option<usize> {
    let iar = read_sysreg!(icc_iar1_el1) as usize;
    if iar >= 0x3fe {
        // spurious
        None
    } else {
        Some(iar as _)
    }
}

fn deactivate_irq(irq_id: usize) {
    write_sysreg!(icc_eoir1_el1, irq_id as u64);
    if irq_id < 16 {
        write_sysreg!(icc_dir_el1, irq_id as u64);
    }
    //write_sysreg!(icc_dir_el1, irq_id as usize);
}

fn read_lr(id: usize) -> u64 {
    let id = id as u64;
    match id {
        //TODO get lr size from gic reg
        0 => read_sysreg!(ich_lr0_el2),
        1 => read_sysreg!(ich_lr1_el2),
        2 => read_sysreg!(ich_lr2_el2),
        3 => read_sysreg!(ich_lr3_el2),
        4 => read_sysreg!(ich_lr4_el2),
        5 => read_sysreg!(ich_lr5_el2),
        6 => read_sysreg!(ich_lr6_el2),
        7 => read_sysreg!(ich_lr7_el2),
        8 => read_sysreg!(ich_lr8_el2),
        9 => read_sysreg!(ich_lr9_el2),
        10 => read_sysreg!(ich_lr10_el2),
        11 => read_sysreg!(ich_lr11_el2),
        12 => read_sysreg!(ich_lr12_el2),
        13 => read_sysreg!(ich_lr13_el2),
        14 => read_sysreg!(ich_lr14_el2),
        15 => read_sysreg!(ich_lr15_el2),
        _ => {
            error!("lr over");
            loop {}
        }
    }
}

fn write_lr(id: usize, val: u64) {
    let id = id as u64;
    match id {
        0 => write_sysreg!(ich_lr0_el2, val),
        1 => write_sysreg!(ich_lr1_el2, val),
        2 => write_sysreg!(ich_lr2_el2, val),
        3 => write_sysreg!(ich_lr3_el2, val),
        4 => write_sysreg!(ich_lr4_el2, val),
        5 => write_sysreg!(ich_lr5_el2, val),
        6 => write_sysreg!(ich_lr6_el2, val),
        7 => write_sysreg!(ich_lr7_el2, val),
        8 => write_sysreg!(ich_lr8_el2, val),
        9 => write_sysreg!(ich_lr9_el2, val),
        10 => write_sysreg!(ich_lr10_el2, val),
        11 => write_sysreg!(ich_lr11_el2, val),
        12 => write_sysreg!(ich_lr12_el2, val),
        13 => write_sysreg!(ich_lr13_el2, val),
        14 => write_sysreg!(ich_lr14_el2, val),
        15 => write_sysreg!(ich_lr15_el2, val),
        _ => {
            error!("lr over");
            loop {}
        }
    }
}

pub fn inject_irq(irq_id: usize, is_hardware: bool) {
    // mask
    const LR_VIRTIRQ_MASK: usize = (1 << 32) - 1;

    let elsr: u64 = read_sysreg!(ich_elrsr_el2);
    let vtr = read_sysreg!(ich_vtr_el2) as usize;
    let lr_num: usize = (vtr & 0xf) + 1;
    let mut free_ir = -1 as isize;
    for i in 0..lr_num {
        // find a free list register
        if (1 << i) & elsr > 0 {
            if free_ir == -1 {
                free_ir = i as isize;
            }
            continue;
        }
        let lr_val = read_lr(i) as usize;
        // if a virtual interrupt is enabled and equals to the physical interrupt irq_id
        if (lr_val & LR_VIRTIRQ_MASK) == irq_id {
            trace!("virtual irq {} enables again", irq_id);
            return;
        }
    }
    // debug!("To Inject IRQ {}, find lr {}", irq_id, free_ir);

    if free_ir == -1 {
        panic!("full lr");
    } else {
        let mut val = irq_id as u64; //v intid
        val |= 1 << 60; //group 1
        val |= 1 << 62; //state pending

        if !is_sgi(irq_id as _) && is_hardware {
            val |= 1 << 61; //map hardware
            val |= (irq_id as u64) << 32; //pINTID
        }
        write_lr(free_ir as usize, val);
    }
}

pub static GIC: Once<Gic> = Once::new();
pub const PER_GICR_SIZE: usize = 0x20000;

#[derive(Debug)]
pub struct Gic {
    pub gicd_base: usize,
    pub gicr_base: usize,
    pub gicd_size: usize,
    pub gicr_size: usize,
}

impl Gic {
    pub fn new(fdt: &Fdt) -> Self {
        let gic_info = fdt
            .find_node("/gic")
            .unwrap_or_else(|| fdt.find_node("/intc").unwrap());
        let mut reg_iter = gic_info.reg().unwrap();

        let first_reg = reg_iter.next().unwrap();
        let second_reg = reg_iter.next().unwrap();

        Self {
            gicd_base: first_reg.starting_address as usize,
            gicr_base: second_reg.starting_address as usize,
            gicd_size: first_reg.size.unwrap(),
            gicr_size: second_reg.size.unwrap(),
        }
    }
}

pub fn host_gicd_base() -> usize {
    GIC.get().unwrap().gicd_base
}

pub fn host_gicr_base(id: usize) -> usize {
    assert!(id < MAX_CPU_NUM);
    GIC.get().unwrap().gicr_base + id * PER_GICR_SIZE
}

pub fn host_gicd_size() -> usize {
    GIC.get().unwrap().gicd_size
}

pub fn host_gicr_size() -> usize {
    GIC.get().unwrap().gicr_size
}

pub fn is_spi(irqn: u32) -> bool {
    irqn > 31 && irqn < 1020
}

pub fn is_sgi(irqn: u32) -> bool {
    irqn < 16
}

pub fn enable_irqs() {
    unsafe { asm!("msr daifclr, #0x2") };
}

pub fn disable_irqs() {
    unsafe { asm!("msr daifset, #0x2") };
}

pub fn primary_init_early(host_fdt: &Fdt) {
    GIC.call_once(|| Gic::new(host_fdt));
    debug!("gic = {:#x?}", GIC.get().unwrap());
}

pub fn primary_init_late() {
    enable_gic_are_ns();
    enable_irqs();
}

pub fn percpu_init() {
    gicc_init();
    enable_ipi();
}

impl Zone {
    pub fn arch_irqchip_reset(&self) {
        let gicd_base = host_gicd_base();
        for (idx, &mask) in self.irq_bitmap.iter().enumerate() {
            if idx == 0 {
                continue;
            }
            unsafe {
                write_volatile((gicd_base + GICD_ICENABLER + idx * 4) as *mut u32, mask);
                write_volatile((gicd_base + GICD_ICACTIVER + idx * 4) as *mut u32, mask);
            }
        }
    }
}
